//! Data abort specific handling

use bitfield_struct::bitfield;
use macros::AsBits;

/// The reason why the data abort was raised
#[derive(AsBits, Debug)]
#[repr(u32)]
enum DataFaultStatusCode {
    AddressSizeFault = 0b0000,
    TranslationFault = 0b0001,
    AccessFlagFault = 0b0010,
    PermissionFault = 0b0011,
    /// Synchronous External abort on translation table walk or hardware update of translation
    /// table
    SynchronousExternalAbort = 0b0101,
    AlignmentFault = 0b1000,
}

#[derive(AsBits, Debug)]
#[repr(u32)]
/// Used when a Translation fault, Access flag fault, or Permission fault generates a Data Abort.
enum LoadStoreType {
    /// The instruction that generated the Data Abort is not specified.
    Unspecified = 0b00,
    /// (FEAT_LS64_V) An `ST64BV` instruction generated the Data Abort.
    St64bb = 0b01,
    /// (FEAT_LS64) An `LD64B` or `ST64B` instruction generated the Data Abort.
    LdSt64B = 0b10,
    /// (FEAT_LS64_ACCDATA) An `ST64BV0` instruction generated the Data Abort.
    St64Bv0 = 0b11,
}

/// Indicates the size of the access attempted by the faulting operation
#[derive(AsBits, Debug)]
#[repr(u16)]
enum AccessSize {
    /// Access was a single byte
    Byte = 0b00,
    /// Access was a halfword (two bytes)
    Halfword = 0b01,
    /// Access was a word (4 bytes)
    Word = 0b10,
    /// Access was a doubleword (8 bytes)
    Doubleword = 0b11,
}

/// The instruction syndrome whenever a Data Abort is taken
#[bitfield(u32)]
pub struct DataAbortIS {
    /// Level of translation at which the data abort occurred. Not always meaningful.
    #[bits(2)]
    level: u8,
    /// Status code indicating the cause of the data abort
    #[bits(4)]
    status_code: DataFaultStatusCode,
    /// Write not Read. Indicates whether a synchronous abort was caused by an instruction writing to a memory location, or by an instruction reading from a memory location
    ///
    /// For faults on cache maintenance and address translation instructions, this bit always
    /// returns a value of 1.
    ///
    /// For faults from an atomic instruction that both reads and writes from a memory location,
    /// this bit is set to 0 if a read of the address specified by the instruction would have
    /// generated the fault which is being reported, otherwise it is set to 1.
    ///
    /// This field is UNKNOWN for:
    /// * An External abort on an Atomic access
    /// * A fault reported using a DFSC value of 0b110101 or 0b110001, indicating an unsupported
    /// Exclusive or atomic access.
    was_write: bool,
    _res0: bool,
    /// Cache maintenance. Indicates whether the Data Abort came from a cache maintenance or
    /// address translation instruction.
    ///
    /// Set if he Data Abort was generated by either the execution of a cache maintenance
    /// instruction or by a synchronous fault on the execution of an address translation
    /// instruction. The `DC ZVA`, `DC GVA`, and `DC GZVA` instructions are not classified as cache
    /// maintenance instructions, and therefore their execution cannot cause this field to be set.
    was_cache_maintenance: bool,
    /// External abort type. This bit can provide an IMPLEMENTATION DEFINED classification of
    /// External aborts.
    external_abort_type: bool,
    /// `FAR` not Valid, for a synchronous External abort other than a synchronous External abort
    /// on a translation table walk
    far_not_valid: bool,
    /// Load/Store Type. Used when a Translation fault, Access flag fault, or Permission fault
    /// generates a Data Abort.
    #[bits(2)]
    load_store_type: LoadStoreType,
    __res0: bool,
    /// Whether or not the data operation has acquire-release semantics
    ///
    /// This field is UNKNOWN when the value of ISV is UNKNOWN.
    is_acquire_release: bool,
    /// Sixty Four bit general-purpose register transfer. Width of the register accessed by the instruction is 64-bit.
    ///
    /// This field is UNKNOWN when the value of ISV is UNKNOWN.
    is_64bit: bool,
    /// Syndrome Register Transfer. The register number of the Wt/Xt/Rt operand of the faulting
    /// instruction.
    ///
    /// If the exception was taken from an Exception level that is using AArch32, then this is the
    /// AArch64 view of the register.
    ///
    /// This field is UNKNOWN when the value of ISV is UNKNOWN.
    #[bits(5)]
    destination_register: u8,
    /// Syndrome Sign Extend. For a byte, halfword, or word load operation, indicates whether the
    /// data item must be sign extended.
    ///
    /// This field is UNKNOWN when the value of ISV is UNKNOWN.
    needs_sign_extension: bool,
    /// Indicates the size of the access attempted by the faulting operation.
    ///
    /// This field is UNKNOWN when the value of ISV is UNKNOWN.
    #[bits(2)]
    access_size: u8,
    /// Indicates whether the syndrome information in the next few bits is valid
    instruction_syndrome_valid: bool,
    #[bits(7)]
    __: u8,
}

/// Handles a data abort
pub fn handle(iss: DataAbortIS) -> i64 {
    let far: u64;
    // SAFETY: This touches nothing but a read to FAR_EL1, safely
    unsafe {
        core::arch::asm! {
            "mrs {}, FAR_EL1",
            out(reg) far,
            options(nomem, nostack, preserves_flags)
        };
    };
    panic!("Faulting address {far:X}, ISS {iss:X?}")
}
